# '''
# EN.520.433 Medical Image Analysis
# Spring 2023

# Step08: Input two contours and output 3d reconstruction using interpolation

# Updated 05.12.2023

# Hannah Qu
# '''

import pickle
import math
import SimpleITK as sitk
import matplotlib.pylab as plt
import cv2
import numpy as np
from helper_functions import pre_process
from itertools import combinations
from scipy import interpolate
from mpl_toolkits.mplot3d import Axes3D
from scipy.interpolate import griddata, make_interp_spline


# 0. Load the variables from the pickle file
patient_idx = 20
# channel_number = 4
out_file_name_2 = "outputs\pickles\patient{0:04d}_{1}_CH_evolution_variables.pkl".format(patient_idx, 2)
out_file_name_4 = "outputs\pickles\patient{0:04d}_{1}_CH_evolution_variables.pkl".format(patient_idx, 4)

with open(out_file_name_2, "rb") as f:
    patient_idx_2 = pickle.load(f)
    channel_number_2 = pickle.load(f)
    lines_2 = pickle.load(f)

    I_2 = pickle.load(f)
    I_gt_2 = pickle.load(f)
    r2_2 = pickle.load(f) # the binary red contour (the most important one)
    
    I_out_2 = pickle.load(f)
    I_seq_2 = pickle.load(f)

    c1_2 = pickle.load(f)
    c2_2 = pickle.load(f)
    c3_2 = pickle.load(f)

with open(out_file_name_4, "rb") as f:
    patient_idx_4 = pickle.load(f)
    channel_number_4 = pickle.load(f)
    lines_4 = pickle.load(f)

    I_4 = pickle.load(f)
    I_gt_4 = pickle.load(f)
    r2_4 = pickle.load(f) # the binary red contour (the most important one)
    
    I_out_4 = pickle.load(f)
    I_seq_4 = pickle.load(f)

    c1_4 = pickle.load(f)
    c2_4 = pickle.load(f)
    c3_4 = pickle.load(f)    

# 2d plot of cross section view, a is x, b is y, AP is true if vertical long axis, false if horizontal long axis
def plot_2d(a, b, AP): 
    fig, ax = plt.subplots()

    if AP: 
        ax.plot(a, b, color="orange")
        # ax.set_xlabel('y1')
        # ax.set_ylabel('x')
        ax.set_title('Vertical Long Axis (4 Chamber Cross Section View)')
    else: 
        ax.plot(a, b, color="blue")
        # ax.set_xlabel('y2')
        # ax.set_ylabel('z')
        ax.set_title('Horizontal Long Axis (2 Chamber Cross Section View)')

# 3d visualization of 2d cross section views, a1 b1 is 
def plot_3d(fig, a1, b1, a2, b2):
    # Plot the XY coordinates
    ax = fig.add_subplot(111, projection = '3d')

    ax.plot(a1, b1, zs=0, zdir='z', label='Horizontal Long Axis')

    # Plot the YZ coordinates
    ax.plot(a2, b2, zs=1, zdir='x', label='Vertical Long Axis')

    # Set labels and title
    ax.set_xlabel('X')
    ax.set_ylabel('Y')
    ax.set_zlabel('Z')
    ax.set_title('LAT and AP Cross Section Views')

    # Add a legend
    ax.legend()

# convert contour coordinate from tuple to list
c1_2 = tuple(tuple(p) for p in np.squeeze(c1_2).tolist()) 
c1_4 = tuple(tuple(p) for p in np.squeeze(c1_4).tolist()) 
c1_2 = np.array(c1_2)
c1_4 = np.array(c1_4)

# extract xy and yz values
x = c1_2[:, 1] # vertical long axis y
y1 = c1_2[:, 0] # vertical long axis x
y2 = c1_4[:, 0] # horizontal long axis x
z = c1_4[:, 1] # horizontal long axis y

# center around 0
x = x - np.mean(x) 
y1 = y1 - np.mean(y1) 
c1_2 = np.column_stack((x, y1))
y2 = y2 - np.mean(y2) 
z = z - np.mean(z) 
c1_4 = np.column_stack((y2, z))

# only keep positive coordinates
c1_2 = c1_2[c1_2[:, 0] > 0]
c1_2 = c1_2[c1_2[:, 1] > 0]
c1_4 = c1_4[c1_4[:, 0] > 0]
c1_4 = c1_4[c1_4[:, 1] > 0]
c1_2 = c1_2[c1_2[:, 0].argsort()]
c1_4 = c1_4[c1_4[:, 0].argsort()]

# extract xy and yz positive
x = c1_2[:, 0] # vertical long axis y
y1 = c1_2[:, 1] # vertical long axis x
y2 = c1_4[:, 0] # horizontal long axis x
z = c1_4[:, 1] # horizontal long axis y

# plotting
plot_2d(y1, x, True) # plot vertical long axis
plot_2d(y2, z, False) # plot horizontal long axis
fig = plt.figure(3)
plot_3d(fig, y2, z, x, y1)
plt.show()


# # Bspline interpolation code from chatgpt
grid_x, grid_y, grid_z = np.meshgrid(np.linspace(min(x), max(x), num=100),
                                     np.linspace(min(y1), max(y1), num=100),
                                     np.linspace(min(z), max(z), num=100))

interp_xy = make_interp_spline(x, y1)
interp_yz = make_interp_spline(y2, z)


